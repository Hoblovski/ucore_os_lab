# 操作系统 lab7

## 练习1: 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题(不需要编码)

### 信号量的实现

* `up(sem)` 的实现: 
    1. `up()` 的全过程需要关中断
    2. 如果没有线程在等待这个信号量 (就是没有线程因为调用 `down(sem)` 而阻塞), 直接返回.
    3. 如果有线程在等待这个信号量, 唤醒那个线程 (从 SLEEPING 变成 RUNNABLE)

* `down(sem)` 的实现:
    1. 同上, 全程关中断, 但是退出 `down()` 时需要开中断
    2. 如果 `sem > 0`, 减少 `sem` 后直接退出
    3. 将当前线程加入 `sem` 的等待队列中, 调用 `schedule()` 退出
    4. (上下文切换切换到当前线程这里) 此时说明 `sem` 已经被满足, 可以继续执行. 退出前将当前线程从 `sem` 的等待队列中删除.

### 信号量实现的哲学家就餐问题

主要有两个函数实现 `phi_take_forks_sema(i)` 和 `phi_put_forks_sema(i)`.

* `phi_take_forks_sema(i)` 中, 大致流程如下 
    0. 进入临界期
    1. 声明自己希望拿叉子, 并尝试拿两把叉子 (会修改 `state[i]`)
    2. 离开临界区
    3. 如果 2. 中尝试拿叉子失败, 阻塞. 直到 `i` 的一个邻居放下叉子后检查发现 `i` 能够拿起叉子.

* `phi_put_forks_sema(i)` 中, 如下
    1. 进入临界区
    2. 声明自己不用叉子了
    3. 检查左边邻居是否是想拿叉子但没能拿到叉子而阻塞, 如果如此则唤醒左边邻居.
    4. 同上告诉右边邻居.
    5. 离开临界区

### 用户态进程/线程提供信号量机制的设计方案

`up()` 和 `down()` 包含特权指令 `cli` 和 `sti`, 因此需要在内核态实现.
因此它们应当被设计为系统调用.

对于不同进程之间的信号量 (用于 IPC 的信号量), 要么要完成进程间共享内存的设计,
要么通过 named semaphore 完成 (用一个字符串标识一个信号量, 内核维护这些信号量).

综上, 需要增加系统调用 `sem_up`, `sem_down` 并且增加内核中维护的一系列信号量.

TODO: 似乎 linux 没有针对信号量设计信号调用?

---

## 练习2: 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题(需要编码)

### 条件变量基本设计
基本基于给出的代码即可.

* `cond_signal(cv)` 的实现, 包含两部分 (当然只有在有线程等待 `cv` 时才执行)
    1. 当前线程执行 `up(cv.sem)` 让等待这个条件的某一个线程激活
    1. 当前线程放弃对 monitor 的执行, 进入 monitor 等待队列

* `cond_wait(cv)` 的实现, 包含  
    1. 当前线程设置 `up(monitor.next)` 使得如果有线程想要进入 monitor 可以进入.
        如果没有线程想要进入 monitor, 则简单的放弃锁使得后来者能够进入.
    1. 当前线程进入等待 `cv` 的状态 `down(cv.sem)`.

### 哲学家就餐问题

拿起叉子和放下叉子的例程和信号量实现的差不多. 但是有如下区别

* 拿起叉子失败时, `cond_wait()` 是在临界区内完成的, 因为 monitor 允许线程临时放弃对 monitor 的独占访问.

* 离开临界区时, 不是简单的松开锁, 而是检查有没有线程等待进入临界区. 如果有的话转交临界区控制权给等待中的线程, 否则才松开锁.

其余都差不多, 就是把 `up()`, `down()` 换成了 `cond_signal()` 和 `cond_wait()`.

### 能否不用基于信号量机制来完成条件变量?

我认为可能. 如下代码所示

```
cv_signal(cv):
    if (无线程正在等待cv)  -----------------------------------+
        return;                                               |
    cv.monitor.n_pending_threads += 1;                        +--> 中断禁用
    放弃 current_thread 对于 cv.monitor 的独占访问 -----------+

    调度(new_condition=cv);

    重新获得 current_thread 对于 cv.monitor 的独占访问 -------> 中断禁用

cv_wait(cv):
    current_thread 进入 cv 的等待队列 ------------------------+
    放弃 current_thread 对于 cv.monitor 的独占访问            +--> 中断禁用
    current_thread 状态为阻塞 --------------------------------+

    调度

    重新获得 current_thread 对于 cv.monitor 的独占访问 ----+-> 中断禁用
    current_thread 从 cv 等待队列中离开 -------------------+
```

并且在调度过程中加入检查传入参数 `new_condition`.
如果非空, 则从 `new_condition` 的等待队列中去一个线程变为 RUNNABLE 态.
