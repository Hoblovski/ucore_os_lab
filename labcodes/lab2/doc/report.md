# 操作系统 lab2

## 练习1:实现 first-fit 连续物理内存分配算法 (需要编程)
### 我的实现
使用明确空块表 (i.e. 链表中只维护空页串), 每个 page frame 的参数明确说明如下
```C
struct Page {                       // 物理页的结构体
    int ref;                        // 此物理页被多少虚拟页引用
    uint32_t flags;                 // 一个bitarray, 其中 位0 表示 不用于动态分配;
                                    //    用于动态分配时, 位1 表示是否可被分配.
    unsigned int property;          // 如果此物理页在一连串的空闲/已分配页中, 是第一个,
                                    //    则为这一连串页的长度; 否则为 0
                                    //    以后称 ``一连串空闲/已分配页中的第一页'' 为 head frame
    list_entry_t page_link;         // 将各个页组织称链表
                                    //    在我的实现中 链表中只有 head frame
};
```
维护的都不是单个的页, 而是连续的一系列页 (即空闲块), 它们要么都是空闲的, 要么都已经被分配.
链表中诸 page frame 按照地址顺序排布.

#### alloc 的实现
有如下过程
1. 遍历链表, 找到第一个足够大的空闲块.

1. 将空闲块中所有 page frame 标为已分配

1. 将这个空闲块从链表中删除

1. 如果空闲块的大小大于请求的大小, 只分配请求的大小,
    之后将余下的作为新的空闲块加入链表

#### free 的实现
有如下过程 (这看起来很不自然, 但是理由后述)
1. 遍历所有空闲块, 如果它和我们要释放的块重叠或邻接, 则将其从链表中删除.
    这相当于起到了将小空闲块合并成大空闲块的作用.
    注意这一过程可能让释放块变得更大, 因为它合并了释放块和原先的空闲块.

1. 如果有被分配的块和我们要释放的块有交集 (主要考虑释放块的两端), 
    则将分配的块分裂成两部分, 一部分不在释放块中, 并更新这一部分的数据.

1. 重写释放块中所有 page frame 的信息, 包括 `flags`, `property`.

1. 将释放块对应的这一大串空闲空间加入链表.

#### 和标准答案的区别
我最初按照写堆 allocator 的思路来, 即`t = malloc(100)`分配的空间只能通过 `free(t)` 来回收.
但是后来我在测试样例中发现了 `free_pages(p0 + 2, 3); ... free_pages(p0 + 2, 3)` 这种代码,
使得我们在释放空间的时候, 释放的空间是否和曾经分配的空间不同 (即测试中那种情况).
因此需要在释放空间的时候遍历所有空闲块.

标准答案是将每一页作为单独的链表项, 而我是将连续的页串作为链表项目.
不过我们分配和释放的时候都需要遍历整个链表, 因此渐进复杂度是相同的.
我认为, 标准答案的编程更加简便, 但是由于链表更长, 所以在实际表现中可能不如我的方法好.
不过我还没有测试过.

#### 进一步改进
* 如果我们要求分配和释放内存按照`new`-`free`对严格配对, 那么`free`可以简单的做到常数复杂度,
    而`alloc`没有太大提升.

* 因为 Page 是依次存放在一个被预留的空间中的, 而 Page 的总数不很多 (在我们的实验中似乎才三万多),
    因此我们可以在 Page 中使用一个域`uint16_t next`来完成类似链表的功能, 而对于非 head frame 的 Page,
    可以让`property`等于负的 "这个 frame 是当前块中第几个" 来完成`prev`指针的功能.
    这样节省了空间 (32*2-16=48位).

