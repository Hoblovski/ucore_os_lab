# 操作系统 lab2

## 练习1:实现 first-fit 连续物理内存分配算法 (需要编程)
### 我的实现
使用明确空块表 (i.e. 链表中只维护空页串), 每个 page frame 的参数明确说明如下
```C
struct Page {                       // 物理页的结构体
    int ref;                        // 此物理页被多少虚拟页引用
    uint32_t flags;                 // 一个bitarray, 其中 位0 表示 不用于动态分配;
                                    //    用于动态分配时, 位1 表示是否可被分配.
    unsigned int property;          // 如果此物理页在一连串的空闲/已分配页中, 是第一个,
                                    //    则为这一连串页的长度; 否则为 0
                                    //    以后称 ``一连串空闲/已分配页中的第一页'' 为 head frame
    list_entry_t page_link;         // 将各个页组织称链表
                                    //    在我的实现中 链表中只有 head frame
};
```
维护的都不是单个的页, 而是连续的一系列页 (即空闲块), 它们要么都是空闲的, 要么都已经被分配.
链表中诸 page frame 按照地址顺序排布.

#### alloc 的实现
有如下过程
1. 遍历链表, 找到第一个足够大的空闲块.

1. 将空闲块中所有 page frame 标为已分配

1. 将这个空闲块从链表中删除

1. 如果空闲块的大小大于请求的大小, 只分配请求的大小,
    之后将余下的作为新的空闲块加入链表

#### free 的实现
有如下过程 (这看起来很不自然, 但是理由后述)
1. 遍历所有空闲块, 如果它和我们要释放的块重叠或邻接, 则将其从链表中删除.
    这相当于起到了将小空闲块合并成大空闲块的作用.
    注意这一过程可能让释放块变得更大, 因为它合并了释放块和原先的空闲块.

1. 如果有被分配的块和我们要释放的块有交集 (主要考虑释放块的两端), 
    则将分配的块分裂成两部分, 一部分不在释放块中, 并更新这一部分的数据.

1. 重写释放块中所有 page frame 的信息, 包括 `flags`, `property`.

1. 将释放块对应的这一大串空闲空间加入链表.

#### 和标准答案的区别
我最初按照写堆 allocator 的思路来, 即`t = malloc(100)`分配的空间只能通过 `free(t)` 来回收.
但是后来我在测试样例中发现了 `free_pages(p0 + 2, 3); ... free_pages(p0 + 2, 3)` 这种代码,
使得我们在释放空间的时候, 释放的空间是否和曾经分配的空间不同 (即测试中那种情况).
因此需要在释放空间的时候遍历所有空闲块.

标准答案是将每一页作为单独的链表项, 而我是将连续的页串作为链表项目.
不过我们分配和释放的时候都需要遍历整个链表, 因此渐进复杂度是相同的.
我认为, 标准答案的编程更加简便, 但是由于链表更长, 所以在实际表现中可能不如我的方法好.
不过我还没有测试过.

#### 进一步改进
* 如果我们要求分配和释放内存按照`new`-`free`对严格配对, 那么`free`可以简单的做到常数复杂度,
    而`alloc`没有太大提升.

* 因为 Page 是依次存放在一个被预留的空间中的, 而 Page 的总数不很多 (在我们的实验中似乎才三万多),
    因此我们可以在 Page 中使用一个域`uint16_t next`来完成类似链表的功能, 而对于非 head frame 的 Page,
    可以让`property`等于负的 "这个 frame 是当前块中第几个" 来完成`prev`指针的功能.
    这样节省了空间 (32*2-16=48位).

---

## 练习2: 实现寻找虚拟地址对应的页表项 (需要编程)

### 简要设计
具体实现参见 `kern/mm/pmm.c:get_pte`. 以下是大致设计思路.

1. 取得页目录项, 检查页表是否存在 (页目录项的 PTE\_P 位为 1)

2. 如果页表不不存在, 则通过 `alloc_page` 分配一页, 设置页引用计数和页目录项

3. 根据页目录项中的基址, 和线性地址中的页表号, 得到对应的页表项.

### 请描述页目录项(PageDirectorEntry)和页表(PageTableEntry)中每个组成部分的含义和以及对ucore而言的潜在用处。
* 高 20 位是 4K 对齐的页表地址 / 页基址; 低 12 位是控制位, 包含如 `PTE_P` (页表 / 页是否在内存中). 

* 页表地址 / 页基址是完成虚拟内存到物理内存映射的必不可少的元素.

* 控制位是完成对内存的保护, 以及更精细访问控制的基础.

### 如果ucore执行过程中访问内存,出现了页访问异常,请问硬件要做哪些事情?
如果这里认为 "页访问异常" 是 PageFault, 则需要

1. 控制器设置PC, 跳转到异常处理例程入口, 完成异常处理

2. 异常处理中从磁盘读取页面时, 需要磁盘读取并且完成时提示 CPU

### 和标准答案的区别
* 分配页表的时候, 如果空间不够, 标准答案是返回 `NULL`, 我认为这是异常情况, 会进入 kernel panic.

* 设置页帧引用计数时, 标准答案直接设置为 1, 我使用的增加. 在本实验中没有区别.

* 分配完页表, 我忘记了初始化页表所在页帧为 0. (已经改正)

---

## 练习3: 释放某虚地址所在的页并取消对应二级页表项的映射 (需要编程)

### 简要设计
具体实现参见 `kern/mm/pmm.c:page_remove_pte`. 以下是大致设计思路.

1. 首先保证要释放的页是存在的, 即 PTE\_P 位为1

2. 释放了页帧, 因此减少页帧的引用计数, 并且达到 0 时调用 `free_page` 释放页

3. 无效化 TLB 中的表项.

### 数据结构Page的全局变量(其实是一个数组)的每一项与页表中的页目录项和页表项有无对应关系?如果有,其对应关系是啥?
有. `pages` 中每一项 `page[i]`, 都表示页号 (地址高20位) 为 `i` 的页.
`pages[i]` 表示 (物理地址的) 基址是 `i*4096` 的物理页.</br>
而页表项和页目录项中, 考虑其内容是 32位数 `e`,
则其代表的 (物理地址的) 页表 / 页基址为 `e & ~0xFFF`.</br>
因此容易从页目录项 / 页表项得到其对应的 `struct Page`, 反之亦然.

### 如果希望虚拟地址与物理地址相等,则需要如何修改lab2,完成此事? 鼓励通过编程来具体完成这个问题
从实验书中相关内容, 包括代码中相关宏如 `#define PADDR(kva) ...` 得到, 需要

1. 修改 `tools/kernel.ld` 中, 第 10 行, 将 0xC0100000 改为 0x00100000.

2. 修改 `kern/mm/memlayout.h` 中, `KERNBASE` 的定义修改为 0.

### 和标准答案的区别
* 我忘记了清空页表项. (已改正)

